@using Microsoft.AspNetCore.Mvc.TagHelpers
@using NHA.Website.Software.Services.RepositoryPatternFoundationals
@using NHA.Website.Software.Views.Shared.Sponsers.ViewModel
@model NHA.Website.Software.Entities.Anime.AnimePage
@inject IUnitOfWork UnitOfWork;

@{
    ViewData["Title"] = @Model.AnimeName;
    Layout = "~/Views/Shared/_Layout.cshtml";
}

@{
    var randomAnime = await UnitOfWork.AnimePageRepository.GetRandomEntityAsync();
}
<div>
    <h2>@Model.AnimeName</h2>
    <hr />


    <div class="row my-auto">
        <h4 class="fw-semibold col-auto my-auto">Anime Preview:</h4>
        <a id="nextLink" class="interactable my-auto col-auto" asp-action="AnimePageDetails" asp-route-id="@randomAnime!.Id" asp-controller="Anime">Next &#x2794;</a>
    </div>

    @{
        int runningCount = Model.UpVotes - Model.DownVotes;

        <div class="row g-3 align-items-start">
            @if (!string.IsNullOrEmpty(Model.AnimeImageUrl))
            {
                <!-- Vote sidebar -->
                <div class="col-auto d-flex flex-column align-items-center me-2">
                    <div class="vote-container d-flex flex-column align-items-center">
                        <button class="vote-btn upvote interactable" data-post-id="@Model.Id">
                            <i class="bi bi-caret-up-fill fs-4"></i>
                        </button>
                        <div class="vote-count fw-bold my-1" id="vote-count-@Model.Id">@runningCount</div>
                        <button class="vote-btn downvote interactable" data-post-id="@Model.Id">
                            <i class="bi bi-caret-down-fill fs-4"></i>
                        </button>
                    </div>
                </div>

                <!-- Anime image -->
                <div class="col-6 col-md-4">
                    <img src="@Model.AnimeImageUrl" alt="@Model.AnimeName's Art Picture" class="img-fluid rounded-2 interactable"/>
                </div>
            }

            <!-- Trailer -->
            @if (!string.IsNullOrEmpty(Model.TrailerUrl))
            {
                <div class="col-12 col-md-7 col-sm-2">
                    <div class="ratio ratio-16x9 rounded-2 overflow-hidden">
                        <iframe src="@Model.TrailerUrl&cc_load_policy=1&cc_lang_pref=en&hl=en"
                                title="YouTube video"
                                allowfullscreen
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
                        </iframe>
                    </div>
                </div>
            }
        </div>

        <hr/>

        <div class="row">
            <div class="col">
                <h4 class="fw-semibold">Meta Data</h4>
                @{
                    if (@Model.AnimeJikanScore != null)
                    {
                        <div>Jikan Score: <strong>@Model.AnimeJikanScore</strong></div>
                    }
                    if (@Model.AnimeStatus != null)
                    {
                        <div>Airing Status: <strong>@Model.AnimeStatus</strong></div>
                    }
                    if (@Model.AnimeGenres != null)
                    {
                        { await Html.RenderPartialAsync("Sponsers/_GenreListPartial", new GenreListVm(@Model.AnimeGenres ?? string.Empty, GenreListType.Anime)); }
                    }
                }
            </div>
            <div class="col">
                <h4 class="fw-semibold">Streaming Platforms</h4>
                @{
                    if (@Model.Platforms != null)
                    {
                        { await Html.RenderPartialAsync("Sponsers/_GenreListPartial", new GenreListVm(@Model.Platforms ?? string.Empty, GenreListType.StreamingPlatform)); }
                    }
                }

            </div>
        </div>




    }
    
    <hr/>

    @{

        if (!string.IsNullOrEmpty(Model.AnimeSummary))
        {
            <h4 class="fw-semibold">Synopsis</h4>
            <div class="AnimeSummary">
                @Html.Raw(@Model.AnimeSummary)
            </div>

            <hr/>
        }

        if (!string.IsNullOrEmpty(Model.AnimeBackground))
        {
            <h4 class="fw-semibold">Background</h4>
            <div class="">
                @Html.Raw(@Model.AnimeBackground)
            </div>
        }
    }

</div>

<div class="mt-3 text-muted small" id="hotkeyHelp">
    💡 Tip:  
    <strong class="text-primary">Ctrl + →</strong> = Next anime  
    |  
    <strong class="text-primary">Ctrl + ←</strong> = Back to previous page
</div>

<style>
            #hotkeyHelp {
                font-size: 0.9rem;
                color: #666;
            }
            #hotkeyHelp strong {
                color: #222;
            }
        </style>

<hr/>



<div>
    <a asp-action="CreateAnimePage" asp-controller="Anime" class="interactable">Edit</a> |
    <a asp-action="Index" class="interactable">Back to List</a> |
    <a id="nextLink" class="interactable" asp-action="AnimePageDetails" asp-route-id="@randomAnime!.Id" asp-controller="Anime">Next &#x2794;</a>
</div>

<script>
    (function () {
      const link = document.getElementById('nextLink');

      // Ignore hotkeys while typing in inputs/textareas/contenteditable
      function isTypingTarget(el) {
        return el && (
          el.tagName === 'INPUT' ||
          el.tagName === 'TEXTAREA' ||
          el.isContentEditable ||
          el.tagName === 'SELECT'
        );
      }

      document.addEventListener('keydown', function (e) {
        if (!link) return;
        if (isTypingTarget(document.activeElement)) return;

        // Hotkey: Ctrl + ArrowRight (change this to what you prefer)
        if (e.ctrlKey && e.key === 'ArrowRight') {
          e.preventDefault();

          // Prefer location change for SPA-like snappiness; click works too.
          const href = link.getAttribute('href');
          if (href) {
            window.location.href = href;
          } else {
            link.click();
          }
        }

        if (e.ctrlKey && e.key === 'ArrowLeft') {
          e.preventDefault();
          window.history.back();
        }
      }, { passive: false });
    })();

        document.addEventListener("DOMContentLoaded", () => {
        // Attach click listeners to all vote buttons
        document.querySelectorAll(".vote-btn").forEach(button => {
            button.addEventListener("click", async (e) => {
                const postId = button.getAttribute("data-post-id");
                const isUpvote = button.classList.contains("upvote");

                try {
                    const response = await fetch(`/api/Like/Anime/${postId}?upvote=${isUpvote}`, {
                        method: "PUT",
                        headers: {
                            "Content-Type": "application/json"
                        }
                    });

                    const result = await response.json();

                    if (result.success) {
                        // Find the vote count element
                        const voteCountElem = document.getElementById(`vote-count-${postId}`);
                        let currentCount = parseInt(voteCountElem.textContent) || 0;

                        // Update locally
                        currentCount += isUpvote ? 1 : -1;
                        voteCountElem.textContent = currentCount;
                    } else {
                        console.log("Vote failed or already applied");
                    }
                } catch (err) {
                    console.error("Error voting:", err);
                }
            });
        });
    });
</script>
